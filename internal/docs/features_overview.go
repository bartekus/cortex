// SPDX-License-Identifier: AGPL-3.0-or-later

/*
Cortex - Cortex is a Go-based CLI that orchestrates local-first development and scalable single-host to multi-host deployments for multi-service applications powered by Docker Compose.

Copyright (C) 2025  Bartek Kus

This program is free software licensed under the terms of the GNU AGPL v3 or later.

See https://www.gnu.org/licenses/ for license details.
*/

package docs

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/bartekus/cortex/internal/features"
	"github.com/bartekus/cortex/internal/specschema"
)

// GenerateFeatureOverview generates docs/inventory/features-overview.md from features.yaml and spec files.
func GenerateFeatureOverview(featuresPath, specRoot, outPath string) error {
	// Load features
	graph, err := features.LoadGraph(featuresPath)
	if err != nil {
		return fmt.Errorf("failed to load features: %w", err)
	}

	// Load all specs to get additional metadata
	specs, err := specschema.LoadAllSpecs(specRoot)
	if err != nil {
		// Non-fatal: we can still generate without spec frontmatter
		specs = []specschema.Spec{}
	}

	// Create spec lookup map keyed by Feature ID
	specMap := make(map[string]specschema.SpecFrontmatter)
	for _, spec := range specs {
		specMap[spec.Frontmatter.Feature] = spec.Frontmatter
	}

	// Generate markdown
	content := generateMarkdown(graph, specMap)

	// Ensure output directory exists
	if err := os.MkdirAll(filepath.Dir(outPath), 0o755); err != nil { //nolint:gosec // output directory needs write permissions
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Write file
	if err := os.WriteFile(outPath, []byte(content), 0o644); err != nil { //nolint:gosec // output file needs read permissions
		return fmt.Errorf("failed to write overview file: %w", err)
	}

	return nil
}

// generateMarkdown generates the markdown content for the overview.
func generateMarkdown(graph *features.Graph, specMap map[string]specschema.SpecFrontmatter) string {
	var sb strings.Builder

	sb.WriteString("# Cortex Features Overview\n\n")
	sb.WriteString("This document is auto-generated from `spec/features.yaml` and spec file frontmatter.\n")
	sb.WriteString("Do not edit this file manually. Regenerate with:\n\n")
	sb.WriteString("```bash\n")
	sb.WriteString("go run ./cmd/cortex features overview\n")
	sb.WriteString("```\n\n")

	// Group features by domain
	byDomain := make(map[string][]*features.FeatureNode)
	for _, node := range graph.Nodes {
		domain := inferDomain(node, specMap)
		byDomain[domain] = append(byDomain[domain], node)
	}

	// Sort domains
	domains := make([]string, 0, len(byDomain))
	for domain := range byDomain {
		domains = append(domains, domain)
	}
	sort.Strings(domains)

	// Feature table
	sb.WriteString("## Features by Domain\n\n")
	sb.WriteString("| ID | Domain | Governance | Implementation | Title | Dependencies |\n")
	sb.WriteString("|----|--------|------------|----------------|-------|--------------|\n")

	for _, domain := range domains {
		nodes := byDomain[domain]
		sort.Slice(nodes, func(i, j int) bool { return nodes[i].ID < nodes[j].ID })

		for _, node := range nodes {
			deps := strings.Join(node.DependsOn, ", ")
			if deps == "" {
				deps = "-"
			}

			gov := node.Governance
			if gov == "" {
				gov = "-"
			}
			impl := node.Implementation
			if impl == "" {
				impl = "-"
			}

			sb.WriteString(fmt.Sprintf("| %s | %s | %s | %s | %s | %s |\n",
				node.ID, domain, gov, impl, node.Title, deps))
		}
	}

	sb.WriteString("\n")

	// Dependency graph
	sb.WriteString("## Dependency Graph\n\n")
	sb.WriteString("The following DOT graph shows feature dependencies (colored by implementation state):\n\n")
	sb.WriteString("```dot\n")
	sb.WriteString(features.ToDOT(graph))
	sb.WriteString("```\n\n")

	// Governance summary
	sb.WriteString("## Governance Summary\n\n")
	govCounts := make(map[string]int)
	for _, node := range graph.Nodes {
		govCounts[node.Governance]++
	}
	sb.WriteString("| Governance | Count |\n")
	sb.WriteString("|------------|-------|\n")
	for _, status := range []string{"draft", "review", "approved", "deprecated"} {
		sb.WriteString(fmt.Sprintf("| %s | %d |\n", status, govCounts[status]))
	}
	sb.WriteString("\n")

	// Implementation summary
	sb.WriteString("## Implementation Summary\n\n")
	implCounts := make(map[string]int)
	for _, node := range graph.Nodes {
		implCounts[node.Implementation]++
	}
	sb.WriteString("| Implementation | Count |\n")
	sb.WriteString("|----------------|-------|\n")
	for _, status := range []string{"todo", "wip", "done", "deprecated"} {
		sb.WriteString(fmt.Sprintf("| %s | %d |\n", status, implCounts[status]))
	}

	return sb.String()
}

// inferDomain tries to infer the domain from spec frontmatter or feature structure.
func inferDomain(node *features.FeatureNode, specMap map[string]specschema.SpecFrontmatter) string {
	// Try spec frontmatter first
	if fm, ok := specMap[node.ID]; ok && fm.Domain != "" {
		return fm.Domain
	}

	// Infer from spec path
	if node.Spec != "" {
		parts := strings.Split(node.Spec, "/")
		if len(parts) > 0 {
			return parts[0]
		}
	}

	// Default
	return "unknown"
}
